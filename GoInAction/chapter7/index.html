<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Philon">


    <meta name="subtitle" content="何以解忧，唯有 i++">


    <meta name="description" content="一个程序员的成长足迹">


    <meta name="keywords" content="自律 arts 编程 开发 c/c++ java web go 读书 写作">


<title>七：并发模式 | 自增人生</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <div class="twolines-nav">
  <div class="twolines-nav-menu" onclick="this.classList.toggle('open-menu')"></div>
  <div class="twolines-nav-darkmode"></div>
  <div class="twolines-nav-prev"></div>
  <div class="twolines-nav-next"></div>
  <div class="twolines-nav-backtop"></div>
</div>

<style>
  .twolines-nav {
    margin-top: 1em;
    cursor: pointer;
  }
  .twolines-nav-menu {
    position: relative;
    top: 0em;
    left: 1em;
    width: 40px;
    height: 15px;
  }
  
  .twolines-nav-menu::before, .twolines-nav-menu::after {
    display: block;
    content: "";
    width: 100%;
    height: 2px;
    background-color: #aaaaaa;
    margin-top: 12px;
    transition: 0.3s;
  }

  .open-menu.twolines-nav-menu::before {
    transform: rotate(45deg) translate(10px, 10px);
  }
  .open-menu.twolines-nav-menu::after {
    transform: rotate(-45deg);
  }
</style>
                <!-- <a href="/">自增人生</a> -->
            </div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/books">读书</a>
                
                    <a class="menu-item" href="/notes">技术</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">自增人生</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/books">读书</a>
                
                    <a class="menu-item" href="/notes">技术</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list"></div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header" title="发表于2019/03/03">
            
            
                <a class="post-category" href="/categories/《GO语言实战》学习笔记/">《GO语言实战》学习笔记</a>
            
            <!-- 
                <div class="post-meta">
                    
                        <span class="post-time">2019/03/03</span>
                    
                </div>
             -->
            
            <h1 class="post-title">七：并发模式</h1>
        </header>

        <div class="post-content">
            <p>我们可以通过goroutine和channel机制非常方便地编写并发业务，但就和面向对象与设计模式的关系一样，是一种思想具体落实到行动方针的过程，在牛逼的战略，没有基本的战术指导，也只是空谈。</p>
<p>因此，第七章并发模式，并没有太多语法上的新东西，而是利用goroutine和channel介绍了三种并发模式，分别适用于三种不同的业务场景。</p>
<ol>
<li>runner——给每个并发任务设置deadline，管理并发任务的生命周期</li>
<li>pool——利用有缓冲通道创建资源池，统一管理并发时的资源访问</li>
<li>work——利用无缓冲通道创建goroutine池，统一管理并发</li>
</ol>
<h2 id="runner"><a href="#runner" class="headerlink" title="runner"></a>runner</h2><p>先假设一个场景需求，比如http服务的并发，我们要为每个来自客户端的请求创建一个临时的并发响应任务，但这个最好在某个规定的时间内完成响应，否则就强制它退出，这样可以很好地避免某些情况下，一些并发任务卡死的情况，同时可以很好地管理每个并发的生命周期。  </p>
<p>runner就是为这样的场景应用而生的，runner可以理解为是一个运行管理器，所有的并发任务都要叫给它负责管理，它负责并发任务的启动、超时监控、强制中断等。</p>
<p>(由于我个人在阅读原著的时候是先讲runner的内部实现，再看实际应用，总感觉云里雾里的，觉得还是先通篇看一下如何运用runner，再来看其内部的实现，可能效果会好一点)</p>
<p>先来看runner的示例：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testRunner</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">"Runner test starting work..."</span>)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 新建一个runner，并强制每个并发任务的超时时间为5秒</span></span><br><span class="line">  r := runner.New(<span class="number">3</span> * time.Second)</span><br><span class="line">  <span class="comment">// 循环创建10个并发任务，并将其丢给runner管理</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">5</span>; i++ &#123;</span><br><span class="line">    r.Add(<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      <span class="comment">// 这里只是模拟，每个并发任务都是睡眠它自身id的秒数</span></span><br><span class="line">      log.Printf(<span class="string">"Processor - Task #%d.\n"</span>, id)</span><br><span class="line">      time.Sleep(time.Duration(id) * time.Second)</span><br><span class="line">      log.Printf(<span class="string">"Task #%d done.\n"</span>, id)</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性启动runner内部的全部并发任务</span></span><br><span class="line">  <span class="keyword">if</span> err := r.Start(); err != <span class="literal">nil</span> &#123;</span><br><span class="line">    <span class="keyword">switch</span> err &#123;</span><br><span class="line">    <span class="keyword">case</span> runner.ErrTimeout:</span><br><span class="line">      <span class="comment">// 当并发任务中有任务执行超时，就立即返回</span></span><br><span class="line">      log.Println(<span class="string">"Terminating due to timeout."</span>)</span><br><span class="line">      os.Exit(<span class="number">1</span>)</span><br><span class="line">    <span class="keyword">case</span> runner.ErrInterrupt:</span><br><span class="line">      <span class="comment">// 当程序被ctrl+c时，强制结束所有并发任务</span></span><br><span class="line">      log.Println(<span class="string">"Terminating due to interrupt."</span>)</span><br><span class="line">      os.Exit(<span class="number">2</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  log.Println(<span class="string">"Process end."</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//-------------程序输出---------------</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Runner test starting work...</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">2.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">4.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">3.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">0.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Task #<span class="number">0</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">41</span> Processor - Task #<span class="number">1.</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">42</span> Task #<span class="number">1</span> done.</span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">43</span> Task #<span class="number">2</span> done.</span><br><span class="line"><span class="comment">// ----第3个及以后的任务因为要睡3秒以上，肯定会超时----</span></span><br><span class="line"><span class="number">2019</span>/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">48</span>:<span class="number">44</span> Terminating due to timeout.</span><br><span class="line"><span class="comment">// ----如何运行过程中按ctrl+c，会安全退出并提示----</span></span><br><span class="line">^C2019/<span class="number">03</span>/<span class="number">03</span> <span class="number">14</span>:<span class="number">49</span>:<span class="number">36</span> Terminating due to interrupt.</span><br></pre></td></tr></table></figure>

<p>可以看到，runner就是一个类型，需要用其创建对象后才能具体使用。而在外部，我们只需要定义好每个任务的函数，并简单的将它们添加到runner当中即可，剩下的全部交由runner自行管理。</p>
<p>现在再来看看runner类型是如何实现的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Runner 在指定的超时时间内完成一组任务</span></span><br><span class="line"><span class="comment">// 并且在这个时间周期内接收系统的中断信号来结束这组任务</span></span><br><span class="line"><span class="keyword">type</span> Runner <span class="keyword">struct</span> &#123;</span><br><span class="line">  <span class="comment">// 从系统接收中断信号的通道</span></span><br><span class="line">  interrupt <span class="keyword">chan</span> os.Signal</span><br><span class="line">  <span class="comment">// 任务已完成的报告通道</span></span><br><span class="line">  complete <span class="keyword">chan</span> error</span><br><span class="line">  <span class="comment">// 任务超时的报告通道</span></span><br><span class="line">  timeout &lt;-<span class="keyword">chan</span> time.Time</span><br><span class="line">  <span class="comment">// 任务列表</span></span><br><span class="line">  tasks []<span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>)</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ErrTimeout</span> 任务执行超时时返回</span></span><br><span class="line">var ErrTimeout = errors.New("received timeout")</span><br><span class="line"></span><br><span class="line"><span class="comment">// ErrInterrupt 收到系统中断信号时返回</span></span><br><span class="line"><span class="keyword">var</span> ErrInterrupt = errors.New(<span class="string">"received interrupt"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Runner的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(d time.Duration)</span> *<span class="title">Runner</span></span> &#123;</span><br><span class="line">  <span class="keyword">return</span> &amp;Runner&#123;</span><br><span class="line">    interrupt: <span class="built_in">make</span>(<span class="keyword">chan</span> os.Signal, <span class="number">1</span>),</span><br><span class="line">    complete:  <span class="built_in">make</span>(<span class="keyword">chan</span> error),</span><br><span class="line">    timeout:   time.After(d),</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Add Runner的方法，将多个任务添加到Runner的任务列表中</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Add</span><span class="params">(tasks ...<span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">  r.tasks = <span class="built_in">append</span>(r.tasks, tasks...)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Start Runner的方法，启动所有任务，并监听通道事件</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(r *Runner)</span> <span class="title">Start</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  <span class="comment">// 开始接收系统的中断通知</span></span><br><span class="line">  signal.Notify(r.interrupt, os.Interrupt)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 通过gorouting并行启动所有任务列表中的任务</span></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="built_in">len</span>(r.tasks))</span><br><span class="line">  <span class="keyword">for</span> i, t := <span class="keyword">range</span> r.tasks &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(id <span class="keyword">int</span>, task <span class="keyword">func</span>(<span class="keyword">int</span>)</span>)</span> &#123;</span><br><span class="line">      task(id)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(i, t)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 等待所有任务执行完成，并给“已完成通道”一个报告</span></span><br><span class="line">  <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">    wg.Wait()</span><br><span class="line">    r.complete &lt;- <span class="literal">nil</span></span><br><span class="line">  &#125;()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 获取无缓冲通道数据时，如果没准备好，会被阻塞</span></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> err := &lt;-r.complete: <span class="comment">// 任务正常实行完返回任务自身的“错误标示”</span></span><br><span class="line">    <span class="keyword">return</span> err</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.timeout: <span class="comment">// 任务执行超时，返回超时错误</span></span><br><span class="line">    <span class="keyword">return</span> ErrTimeout</span><br><span class="line">  <span class="keyword">case</span> &lt;-r.interrupt: <span class="comment">// 如果收到ctrl+C则停止接收后续的信号</span></span><br><span class="line">    signal.Stop(r.interrupt)</span><br><span class="line">    <span class="keyword">return</span> ErrInterrupt</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于只是原型演示，runner的内部实现不算复杂，只需要记住一个核心思想<strong>无缓冲通道在没有数据读写的时候，会被阻塞</strong>。说千道万，runner就是利用了这个特性才得以在select语句中完成了：</p>
<ul>
<li>并行接收系统的中断信号——interrupt通道。</li>
<li>并行接收定时器的超时信号——timeout通道。</li>
</ul>
<h2 id="pool"><a href="#pool" class="headerlink" title="pool"></a>pool</h2><p>这里的pool是指资源池的意思，如果熟悉Java/C#中的“数据连接池”的概念，那这里的池大体就是这个意思了。</p>
<p>换而言之，在并发场景下，难免会遇到并发任务争夺临界资源的情况，还是以数据库访问为例：如果有1000个并发任务要去访问数据库，每个并发都需要完成建立连接——认证——查询——断开连接等操作，那不论是应用服务器还是数据库服务器，无疑都是巨大的负担。因此，通过创建10个数据库连接，并把这些“连接”当作资源放入“池”中，给所有的并发任务共享，每个并发在需要的时候从池中取出连接，完成查询后再放回池中，不仅能大幅降低CPU的负载，也能减少内存的开销。(但我个人觉得最爽的地方是，你的代码可以更专注地去query，而不必考虑connection本身😂)</p>
<p>同样，先来看看pool的运用过程：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> (</span><br><span class="line">  maxGoroutines  = <span class="number">25</span> <span class="comment">// 要使用的goroutine的数量</span></span><br><span class="line">  pooledResource = <span class="number">5</span>  <span class="comment">// 池中的资源的数量</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// dbConnection 模拟要共享的资源</span></span><br><span class="line"><span class="keyword">type</span> dbConnection <span class="keyword">struct</span> &#123;</span><br><span class="line">  ID <span class="keyword">int32</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 实现io.Closer.Close接口，释放资源</span></span><br><span class="line"><span class="comment">// 让其可以被Pool管理</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(dbConn *dbConnection)</span> <span class="title">Close</span><span class="params">()</span> <span class="title">error</span></span> &#123;</span><br><span class="line">  log.Println(<span class="string">"Close: Connection"</span>, dbConn.ID)</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// idCounter 用来给每个连接分配唯一id</span></span><br><span class="line"><span class="keyword">var</span> idCounter <span class="keyword">int32</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// createConnection 创建唯一id的连接</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">createConnection</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  id := atomic.AddInt32(&amp;idCounter, <span class="number">1</span>)</span><br><span class="line">  log.Println(<span class="string">"Create: New Connection"</span>, id)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;dbConnection&#123;id&#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// testPool Pool测试用例</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testPool</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(maxGoroutines)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建管理连接池，并创建N个“连接”资源，加入池中</span></span><br><span class="line">  p, err := pool.New(createConnection, pooledResource)</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 创建M个并发任务，模拟查询数据库</span></span><br><span class="line">  <span class="keyword">for</span> query := <span class="number">0</span>; query &lt; maxGoroutines; query++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">(q <span class="keyword">int</span>)</span></span> &#123;</span><br><span class="line">      performQueries(q, p)</span><br><span class="line">      wg.Done()</span><br><span class="line">    &#125;(query)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  wg.Wait()</span><br><span class="line">  log.Println(<span class="string">"Shutdown Program"</span>)</span><br><span class="line">  p.Close() <span class="comment">// 关闭池</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">performQueries</span><span class="params">(query <span class="keyword">int</span>, p *pool.Pool)</span></span> &#123;</span><br><span class="line">  conn, err := p.Acquire()</span><br><span class="line">  <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Println(err)</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 完成查询后，将资源释放会池里</span></span><br><span class="line">  <span class="keyword">defer</span> p.Release(conn)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 用随机睡眠1000微妙内的时长，来模拟查询中的耗时</span></span><br><span class="line">  time.Sleep(time.Duration(rand.Intn(<span class="number">1000</span>)) * time.Millisecond)</span><br><span class="line">  log.Printf(<span class="string">"QID[%d] CID[%d]\n"</span>, query, conn.(*dbConnection).ID)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>(可能是我没学习到位，我个人觉得pool模式并不是特别容易掌握，思想是很好理解的，但牵扯太多接口实现、有/无缓冲通道的特性等内容，所以代码可能要再多消化几遍。)</p>
<p>再看看pool包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Pool 资源池</span></span><br><span class="line"><span class="comment">// 管理一组资源，可以安全地在多个goroutine共享</span></span><br><span class="line"><span class="comment">// 实现 io.Closer接口</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  m        sync.Mutex</span><br><span class="line">  resource <span class="keyword">chan</span> io.Closer</span><br><span class="line">  factory  <span class="function"><span class="keyword">func</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span></span><br><span class="line"><span class="function">  <span class="title">closed</span>   <span class="title">bool</span></span></span><br><span class="line"><span class="function">&#125;</span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function">// <span class="title">ErrPoolClosed</span> 资源池已关闭的错误标示</span></span><br><span class="line">var ErrPoolClosed = errors.New("Pool has been closed")</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建Pool的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(fn <span class="keyword">func</span>()</span> <span class="params">(io.Closer, error)</span>, <span class="title">size</span> <span class="title">uint</span>) <span class="params">(*Pool, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">if</span> size &lt;= <span class="number">0</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span>, errors.New(<span class="string">"size value too small"</span>)</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;Pool&#123;</span><br><span class="line">    factory:  fn,</span><br><span class="line">    resource: <span class="built_in">make</span>(<span class="keyword">chan</span> io.Closer, size),</span><br><span class="line">  &#125;, <span class="literal">nil</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Acquire 从资源池中获取一个资源</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Acquire</span><span class="params">()</span> <span class="params">(io.Closer, error)</span></span> &#123;</span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> r, ok := &lt;-p.resource:</span><br><span class="line">    <span class="comment">// 检查是否有空闲资源</span></span><br><span class="line">    log.Println(<span class="string">"Acquire:"</span>, <span class="string">"Shared Resource"</span>)</span><br><span class="line">    <span class="keyword">if</span> !ok &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">nil</span>, ErrPoolClosed</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> r, <span class="literal">nil</span></span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果没有可用资源，就创建一个</span></span><br><span class="line">    log.Println(<span class="string">"Acquire:"</span>, <span class="string">"New Resource"</span>)</span><br><span class="line">    <span class="keyword">return</span> p.factory()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Release 释放一个资源，将其放回资源池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Release</span><span class="params">(r io.Closer)</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 如果该资源已经被关闭，销毁这个资源</span></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">select</span> &#123;</span><br><span class="line">  <span class="keyword">case</span> p.resource &lt;- r:</span><br><span class="line">    <span class="comment">// 试图将该资源加入队列</span></span><br><span class="line">    log.Println(<span class="string">"Release:"</span>, <span class="string">"In Queue"</span>)</span><br><span class="line">  <span class="keyword">default</span>:</span><br><span class="line">    <span class="comment">// 如果队列已满，关闭这个资源</span></span><br><span class="line">    log.Println(<span class="string">"Release:"</span>, <span class="string">"Closing"</span>)</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Close 关闭资源池中的所有资源，并停止工作</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Close</span><span class="params">()</span></span> &#123;</span><br><span class="line">  p.m.Lock()</span><br><span class="line">  <span class="keyword">defer</span> p.m.Unlock()</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> p.closed &#123;</span><br><span class="line">    <span class="keyword">return</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.closed = <span class="literal">true</span></span><br><span class="line"></span><br><span class="line">  <span class="built_in">close</span>(p.resource)</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭所有资源</span></span><br><span class="line">  <span class="keyword">for</span> r := <span class="keyword">range</span> p.resource &#123;</span><br><span class="line">    r.Close()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pool资源池实现的核心思想是<strong>有缓冲通道读写时不会引起阻塞，select语句在通道内没有数据的情况下会自动执行default选项</strong>。</p>
<h2 id="work"><a href="#work" class="headerlink" title="work"></a>work</h2><p>work模式就是创建一个goroutine池，管理池中所有的goroutine统一执行。但它有别于runner模式，runner其实是负责监控池中的每个并发任务的生命周期的，而work则是负责池中的每个并发任务的执行顺序，即任务队列。</p>
<p>这个模式的好处在于，可以很好地控制程序运行的负载，比如突发情况下，某台服务器的http请求一瞬间到达100万，如果为了响应所有请求也在一瞬起启动100万个响应任务，那估计服务器就冒烟了。所以最好的方式就是限制并发任务数量，比如每次最多启动1万个响应，剩下的排队慢慢来。</p>
<p>因此，work就是一个并发任务的队列池，还是先看看如何运用的：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> names = []<span class="keyword">string</span>&#123;</span><br><span class="line">  <span class="string">"steve"</span>,</span><br><span class="line">  <span class="string">"bob"</span>,</span><br><span class="line">  <span class="string">"mary"</span>,</span><br><span class="line">  <span class="string">"therese"</span>,</span><br><span class="line">  <span class="string">"jason"</span>,</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> namePrinter <span class="keyword">struct</span> &#123;</span><br><span class="line">  name <span class="keyword">string</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Task 实现Worker接口</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(m *namePrinter)</span> <span class="title">Task</span><span class="params">()</span></span> &#123;</span><br><span class="line">  log.Println(m.name)</span><br><span class="line">  time.Sleep(time.Second)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">testWork</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="comment">// 设置工作池的“工位”为2，即每次只能有两个人工作</span></span><br><span class="line">  p := work.New(<span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> wg sync.WaitGroup</span><br><span class="line">  wg.Add(<span class="number">100</span> * <span class="built_in">len</span>(names)) <span class="comment">// 每人肩负100项任务，共5人</span></span><br><span class="line"></span><br><span class="line">  <span class="comment">// 一次性把5 * 100个任务全部丢到工作池中</span></span><br><span class="line">  <span class="comment">// 相当于创建了500个goroutine</span></span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">100</span>; i++ &#123;</span><br><span class="line">    <span class="keyword">for</span> _, name := <span class="keyword">range</span> names &#123;</span><br><span class="line">      np := namePrinter&#123;name: name&#125;</span><br><span class="line">      <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">        p.Run(&amp;np) <span class="comment">// 将对象的任务丢到工作池中统一管理执行</span></span><br><span class="line">        wg.Done()</span><br><span class="line">      &#125;()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等待所有任务在工作池中被完成</span></span><br><span class="line">  wg.Wait()</span><br><span class="line">  p.Shutdown()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如上代码，namePrinter实现了work包内规定的<code>Task</code>接口之后，work的工作池就能够统一管理namePrinter对象了。这个namePrinter可以理解为某个业务的模拟，比如上面说的http响应任务(这里仅是简单地做个打印)。</p>
<p>而后，不论创建多少个namePrinter相关的goroutine(并发)，都只需简单地将其丢到工作池中Run(p.Run并没有立刻启动任务，工作池会根据情况自行安排)。</p>
<p>最后在看看work包的实现：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Worker 必须满足接口，才能使用工作池</span></span><br><span class="line"><span class="keyword">type</span> Worker <span class="keyword">interface</span> &#123;</span><br><span class="line">  Task()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Pool 工作池，相当于goroutines池管理</span></span><br><span class="line"><span class="keyword">type</span> Pool <span class="keyword">struct</span> &#123;</span><br><span class="line">  work <span class="keyword">chan</span> Worker</span><br><span class="line">  wg   sync.WaitGroup</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// New 创建工作池的工厂函数</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">New</span><span class="params">(maxGoroutines <span class="keyword">int</span>)</span> *<span class="title">Pool</span></span> &#123;</span><br><span class="line">  p := Pool&#123;</span><br><span class="line">    work: <span class="built_in">make</span>(<span class="keyword">chan</span> Worker),</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  p.wg.Add(maxGoroutines)</span><br><span class="line">  <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; maxGoroutines; i++ &#123;</span><br><span class="line">    <span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="comment">// p.work是通道，所有创建goroutine之后</span></span><br><span class="line">      <span class="comment">// for循环会被阻塞，直到p.work被关闭为止</span></span><br><span class="line">      <span class="keyword">for</span> w := <span class="keyword">range</span> p.work &#123;</span><br><span class="line">        w.Task()</span><br><span class="line">      &#125;</span><br><span class="line">      p.wg.Done()</span><br><span class="line">    &#125;()</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> &amp;p</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Run 提交工作到工作池</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Run</span><span class="params">(w Worker)</span></span> &#123;</span><br><span class="line">  p.work &lt;- w</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Shutdown 等待所有goroutines结束</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(p *Pool)</span> <span class="title">Shutdown</span><span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">close</span>(p.work)</span><br><span class="line">  p.wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>work的实现其实是非常简单的，<strong>核心思想是for-range循环时，无缓冲通道会阻塞</strong>，工作池是一个无缓冲通道，而每个for-range都相当于一个队列，当池中有数据是，所有的for-range都会争夺这个输入数据来处理，但如果某个队列本身已经在工作时，就没空再争夺通道内的数据。可以说是最简单有效的负载均衡。</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ul>
<li>无缓冲通道在读写时会引起阻塞，可以用来控制程序生命周期</li>
<li>带default分支的select语句会尝试读写通道，而不会阻塞</li>
<li>可以利用无缓冲通道创建一个工作池，统一管理goroutine并发任务</li>
<li>可以利用有缓冲通道创建一个资源池，统一管理并发时的资源访问</li>
</ul>

        </div>

        
        <section class="post-tags">
            <span class="tag">
                
                
                    <a href="/tags/GO语言/">GO语言</a>
                
                    
            </span>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/books/乌合之众/">三人为虎-《乌合之众》读书感悟</a>
            
            
            <a class="next" rel="next" href="/97ThingsEveryProgrammerShouldKnow/30/">不要重复自我</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Philon | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
