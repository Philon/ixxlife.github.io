<!DOCTYPE html>
<html lang="zh-CN">
<head><meta name="generator" content="Hexo 3.9.0">
    <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
<meta http-equiv="X-UA-Compatible" content="ie=edge">

    <meta name="author" content="Philon">


    <meta name="subtitle" content="何以解忧，唯有 i++">


    <meta name="description" content="一个程序员的成长足迹">


    <meta name="keywords" content="自律 arts 编程 开发 c/c++ java web go 读书 写作">


<title>三：包与工具链 | 自增人生</title>



    <link rel="icon" href="/favicon.ico">




    <!-- stylesheets list from _config.yml -->
    
    <link rel="stylesheet" href="/css/style.css">
    



    <!-- scripts list from _config.yml -->
    
    <script src="/js/script.js"></script>
    
    <script src="/js/tocbot.min.js"></script>
    



    
    
        
    


</head>
<body>
    <div class="wrapper">
        <header>
    <nav class="navbar">
        <div class="container">
            <div class="navbar-header header-logo">
                <div class="twolines-nav">
  <div class="twolines-nav-menu" onclick="this.classList.toggle('open-menu')"></div>
  <div class="twolines-nav-darkmode"></div>
  <div class="twolines-nav-prev"></div>
  <div class="twolines-nav-next"></div>
  <div class="twolines-nav-backtop"></div>
</div>

<style>
  .twolines-nav {
    margin-top: 1em;
    cursor: pointer;
  }
  .twolines-nav-menu {
    position: relative;
    top: 0em;
    left: 1em;
    width: 40px;
    height: 15px;
  }
  
  .twolines-nav-menu::before, .twolines-nav-menu::after {
    display: block;
    content: "";
    width: 100%;
    height: 2px;
    background-color: #aaaaaa;
    margin-top: 12px;
    transition: 0.3s;
  }

  .open-menu.twolines-nav-menu::before {
    transform: rotate(45deg) translate(10px, 10px);
  }
  .open-menu.twolines-nav-menu::after {
    transform: rotate(-45deg);
  }
</style>
                <!-- <a href="/">自增人生</a> -->
            </div>
            <div class="menu navbar-right">
                
                    <a class="menu-item" href="/books">读书</a>
                
                    <a class="menu-item" href="/notes">技术</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
                <input id="switch_default" type="checkbox" class="switch_default">
                <label for="switch_default" class="toggleBtn"></label>
            </div>
        </div>
    </nav>

    
    <nav class="navbar-mobile" id="nav-mobile">
        <div class="container">
            <div class="navbar-header">
                <div>
                    <a href="/">自增人生</a><a id="mobile-toggle-theme">·&nbsp;Light</a>
                </div>
                <div class="menu-toggle" onclick="mobileBtn()">&#9776; Menu</div>
            </div>
            <div class="menu" id="mobile-menu">
                
                    <a class="menu-item" href="/books">读书</a>
                
                    <a class="menu-item" href="/notes">技术</a>
                
                    <a class="menu-item" href="/category">Categories</a>
                
                    <a class="menu-item" href="/tag">Tags</a>
                
                    <a class="menu-item" href="/about">About</a>
                
            </div>
        </div>
    </nav>

</header>
<script>
    var mobileBtn = function f() {
        var toggleMenu = document.getElementsByClassName("menu-toggle")[0];
        var mobileMenu = document.getElementById("mobile-menu");
        if(toggleMenu.classList.contains("active")){
           toggleMenu.classList.remove("active")
            mobileMenu.classList.remove("active")
        }else{
            toggleMenu.classList.add("active")
            mobileMenu.classList.add("active")
        }
    }
</script>
        <div class="main">
            <div class="container">
    
    
        <div class="post-toc">
    <div class="tocbot-list"></div>
</div>

<script>
    document.ready(
        function () {
            tocbot.init({
                tocSelector: '.tocbot-list',
                contentSelector: '.post-content',
                headingSelector: 'h1, h2, h3, h4, h5',
                collapseDepth: 1,
                orderedList: false,
                scrollSmooth: true,
            })
        }
    )

    function expand_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 6,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "collapse_toc()");
        b.innerHTML = "Collapse all"
    }

    function collapse_toc() {
        var b = document.querySelector(".tocbot-toc-expand");
        tocbot.init({
            tocSelector: '.tocbot-list',
            contentSelector: '.post-content',
            headingSelector: 'h1, h2, h3, h4, h5',
            collapseDepth: 1,
            orderedList: false,
            scrollSmooth: true,
        });
        b.setAttribute("onclick", "expand_toc()");
        b.innerHTML = "Expand all"
    }

    function go_top() {
        window.scrollTo(0, 0);
    }

    function go_bottom() {
        window.scrollTo(0, document.body.scrollHeight);
    }

</script>
    

    
    <article class="post-wrap">
        <header class="post-header" title="发表于2019/02/03">
            
            
                <a class="post-category" href="/categories/《GO语言实战》学习笔记/">《GO语言实战》学习笔记</a>
            
            <!-- 
                <div class="post-meta">
                    
                        <span class="post-time">2019/02/03</span>
                    
                </div>
             -->
            
            <h1 class="post-title">三：包与工具链</h1>
        </header>

        <div class="post-content">
            <p>结束了上一章地狱般的折麽，从本章开始便重新回归胎教级别，如果说第二章的内容已经完全掌握，我觉得剩下的第3～5章基本可以略过了。</p>
<h2 id="“包”的基础知识"><a href="#“包”的基础知识" class="headerlink" title="“包”的基础知识"></a>“包”的基础知识</h2><p>如果连“包”的基本概念都不了解，那就先别往下看了，去学学Java的基础知识吧。本书没有过多概念性的解释，而是具体说明在GO语言中，如何定义和使用包。</p>
<h3 id="1-包的定义-命名"><a href="#1-包的定义-命名" class="headerlink" title="1. 包的定义(命名)"></a>1. 包的定义(命名)</h3><p>包名应全部小写，每个.go文件都必须在第一行使用<code>package &lt;name&gt;</code>声明自己属于哪个包，同一个目录下不同的go源码必须声明为同一个包。此外，不同路径下的包名是可以相同的，因为<strong>导入包时采用的是全路径</strong>，路径本身可以区分不同的包。</p>
<p>另外，<code>main包</code>很特殊，如果一个工程内编译器没有找到main包，就不会创建可执行文件，<code>main()</code>函数也必须在main包中定义。</p>
<h3 id="2-包的引用-导入"><a href="#2-包的引用-导入" class="headerlink" title="2. 包的引用(导入)"></a>2. 包的引用(导入)</h3><p><strong>导入方式</strong></p>
<p>go语言支持<strong>远程导入、本地导入和命名导入</strong>:</p>
<ul>
<li>本地导入——<code>import &quot;fmt&quot;</code></li>
<li>远程导入——<code>import “github.com/spf13/viper”</code></li>
<li>命名导入——<code>import myFmt &quot;fmt&quot;</code></li>
</ul>
<p>本地/远程导入，都是为了能愉快地使用别人已经写好的功能，不必重新发明轮子。而命名导入主要是为了方式<strong>重名包</strong>，例如：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个buffer包名相同，存在冲突，调用时有歧义</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"request/buffer"</span></span><br><span class="line">  <span class="string">"response/buffer"</span></span><br><span class="line">)</span><br><span class="line">buffer.ToJson()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 给不同的包命名，消除歧义</span></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  买了否冷 <span class="string">"request/buffer"</span></span><br><span class="line">  否冷 <span class="string">"response/buffer"</span></span><br><span class="line">)</span><br><span class="line">买了否冷.ToJson()</span><br><span class="line">否冷.ToImage()</span><br><span class="line"></span><br><span class="line"><span class="comment">// 顺带提一句，go使用utf8编码，虽然可以用中文符号，但不建议，这里仅仅是为了说明问题</span></span><br></pre></td></tr></table></figure>

<p>此外，不管用哪种方式导入，编译器都会<strong>先从GO的安装路径$GOROOT中寻找，没有的话就是$GOPATH中查找</strong>。</p>
<p>⚠️注意：<br>本地导入和远程导入从本质上讲没有区别。远程导入就是先从网上把第三方库下载到GOPATH当中，当作本地库import。</p>
<p><strong>GOROOT和GOPATH</strong> </p>
<p>一个C/C++程序员(我是说我)比较容易犯的一个概念性错误——通过相对路径导入。举个例子：</p>
<p>如果某个工程源码结构是这样的：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">project/</span><br><span class="line">|---packages/</span><br><span class="line">|   |---/pkg1/...</span><br><span class="line">|   |---/pkg2/...</span><br><span class="line">|---main.go</span><br></pre></td></tr></table></figure>

<p>在上边👆的目录结构可以看到，packages目录和main.go文件在同一级目录下，如果习惯了C/C++的思想，会这样导入packages下面的包：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> (</span><br><span class="line">  <span class="string">"packages/pkg1"</span></span><br><span class="line">  <span class="string">"packages/pkg2"</span></span><br><span class="line">)</span><br><span class="line"><span class="comment">// 如果不设置GOPATH，直接导入是不行的🙅🙅🙅！！</span></span><br></pre></td></tr></table></figure>

<p>从相对路径的角度来看，这么干没问题，但我们忽略了<code>GOROOT/GOPATH</code>两个环境变量，GO语言只会从根据这两个环境变量去寻找包。</p>
<ul>
<li><code>GOROOT</code>通常是go语言安装路径，比如<code>/usr/local/go/</code></li>
<li><code>GOPATH</code>通常是用户自定义包路径</li>
</ul>
<p>这种套路非常类似于Java项目开发中的JAVA_HOME、CLASSPATH的概念。</p>
<p>需要注意一点，go编译器会自动为这两个环境后追加src目录，也就是说工程依赖的包应该放在<code>$GOPATH/src</code>内。换而言之，上边的packages目录必须放置在project/src内，并将工程目录添加到GOPATH中。</p>
<h3 id="3-远程导入的坑"><a href="#3-远程导入的坑" class="headerlink" title="3. 远程导入的坑"></a>3. 远程导入的坑</h3><p>如果是远程导入，可以使用<code>go get</code>命令，下来源码中声明的“远程包”，它还会自动下载和更新各种依赖，但由于防火&lt;哔哔&gt;的缘故，这个命令大概率会timeout，只能曲线救国…</p>
<p>说明一下原因，当使用<code>go get -v</code>自动下载依赖包的时候，就可以看到整个过程，会默认去访问<code>https://golang.org/x/&lt;pkg&gt;</code>更新这些依赖，而golang.org的背后是一家名叫Google的公司在运营，由于我个遵纪守法的好公民，在我心目中只要我听不到看不到，它就不存在，是的，从小就在书本里学到一个成语——掩耳盗铃。</p>
<p>所以，我很奇怪，为什么go命令行要去访问一个根本不存在的网站，可能是个bug。好在机智如我，GitHub的GO仓库其实本质上就是golang.org/x 的镜像，所以务必记住这个<strong>镜像地址</strong>： </p>
<p>👉 <a href="https://github.com/golang" target="_blank" rel="noopener">github.com/golang</a> 👈</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">✍️划重点✍️</span><br><span class="line">上面说了，远程导入无非是先把对应url的第三方库下载到GOPATH，既然自动下载不了，那为什么不手动在GOPATH中创建同名目录呢？</span><br><span class="line"></span><br><span class="line">1. 我们可以在GOPATH下创建golang包的目录 </span><br><span class="line">    mkdir -p $GOPATH/golang.org/x</span><br><span class="line">2. 通过GitHub的go仓库，把需要的库克隆到这个目录，例如</span><br><span class="line">   git clone https://github.com/golang/sys.git</span><br><span class="line"></span><br><span class="line">妈妈再也不用担心 import &quot;golang.org/x/sys&quot;</span><br><span class="line"></span><br><span class="line">终极奥义：就是用第一个网址替换第二个</span><br><span class="line">https://github.com/golang/PKG</span><br><span class="line">https://golang.org/x/PKG</span><br></pre></td></tr></table></figure>

<h3 id="4-使用下划线占位符"><a href="#4-使用下划线占位符" class="headerlink" title="4. 使用下划线占位符"></a>4. 使用下划线占位符</h3><p>之前已经学习到，每个包内的<code>init</code>函数总是先于<code>main</code>函数执行，但<strong>前提是这个包在程序中被导入了</strong>。</p>
<p>很多时候，我们需要执行包内的<code>init()</code>函数来初始化某些资源，但我们不会去直接调用包内的任何变量。由于GO的限制，<strong>不允许导入一个根本不曾使用的包</strong>。</p>
<p>那么问题来了，如何导入一个包，却表面上不使用它？<br><code>import _ &lt;package_name&gt;</code>是个不错的选择。</p>
<h2 id="GO的工具链"><a href="#GO的工具链" class="headerlink" title="GO的工具链"></a>GO的工具链</h2><p>对于我们这些Linux出身的猿类来说，敲命令来管理工程是非常有吸引力的，因为可以了解并掌握更多细节，自由度更高。</p>
<p>不论官方还是社区，go语言提供了非常丰富的命令，书中列举不是很多，我也觉得这种东西更适合直接看手册，我在此仅总结几个新手常用的，便于巩固记忆。</p>
<h3 id="go"><a href="#go" class="headerlink" title="go"></a>go</h3><ul>
<li><code>go build</code>构建工程</li>
<li><code>go clean</code>清理工程</li>
<li><code>go run &lt;file.go&gt;</code>运行工程源码，其实是后台自动帮你完成构建</li>
<li><code>go doc &lt;key&gt;</code>命令行文档查看器，包、函数、符号等具体使用规则</li>
</ul>
<h3 id="gb"><a href="#gb" class="headerlink" title="gb"></a>gb</h3><p>作为go新手，我可能还没体验过大型项目那种复杂的依赖关系，但作为nodejs、java的实践者，我很清楚依赖管理的好处。不论是npm还是maven，它们对效率的提升是巨大的。</p>
<p>gb源自社区，目的是解决go的第三方依赖问题。试想一下，对于一个大型项目，几十上百个第三方库，不同的版本，库与库之间的藕断丝连，一个个去筛查定位，无疑是在浪费生命。</p>
<p>gb其实就是在工程目录下，创建一个vendor目录，里面存放各种需要的依赖库，gb会自动下载、更新这些库文件，不用开发者操心(总之用过npm/maven的人都懂，懒得解释了)。</p>
<p>自己的工程目录就放在src目录下，不会和第三方的依赖有刮扯，需要构建工程的时候，仅需<code>gb build all</code>，搞定！</p>
<h2 id="小结一下"><a href="#小结一下" class="headerlink" title="小结一下"></a>小结一下</h2><ol>
<li>GO包管理采用绝对路径，务必注意GOROOT和GOPATH环境变量</li>
<li>GO有本地、远程、命名三种导入包的方式</li>
<li>远程导入可能会timeout，记得替换为GitHub的镜像仓库</li>
<li>仅需要执行包内的init函数时，可以使用下划线占位符</li>
<li>go命令的build/clean/run/doc是很常用的命令工具</li>
<li>学会采用依赖管理工具来管理项目，如gb</li>
</ol>

        </div>

        
        <section class="post-tags">
            <span class="tag">
                
                
                    <a href="/tags/GO语言/">GO语言</a>
                
                    
            </span>
        </section>
        <section class="post-nav">
            
                <a class="prev" rel="prev" href="/97ThingsEveryProgrammerShouldKnow/24/">不要害怕打破事情</a>
            
            
            <a class="next" rel="next" href="/97ThingsEveryProgrammerShouldKnow/23/">领域专用语言</a>
            
        </section>


    </article>
</div>

        </div>
        <footer id="footer" class="footer">
    <div class="copyright">
        <span>© Philon | Powered by <a href="https://hexo.io" target="_blank">Hexo</a> & <a href="https://github.com/Siricee/hexo-theme-Chic" target="_blank">Chic</a></span>
    </div>
</footer>

    </div>
</body>
</html>
