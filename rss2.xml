<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0"
  xmlns:atom="http://www.w3.org/2005/Atom"
  xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>自增人生</title>
    <link>https://ixx.life/</link>
    <atom:link href="/rss2.xml" rel="self" type="application/rss+xml"/>
    
    <description>一个程序员的成长足迹</description>
    <pubDate>Wed, 22 Apr 2020 15:31:54 GMT</pubDate>
    <generator>http://hexo.io/</generator>
    
    <item>
      <title>读《白夜行》</title>
      <link>https://ixx.life//books/%E7%99%BD%E5%A4%9C%E8%A1%8C//</link>
      <guid>https://ixx.life//books/%E7%99%BD%E5%A4%9C%E8%A1%8C//</guid>
      <pubDate>Wed, 22 Apr 2020 14:00:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;昨晚一直读到凌晨1点，酣畅淋漓。好久没有这么爽快了，这或许就是读小说的乐趣所在吧，不必绞尽脑汁去思考，只需要把身体摆成“大”字，跟随剧情，一点点被感染。读到结尾时，我甚至有种舍不得读完的感觉：“啊？就要结束了，谜团还没完全解开呐…”&lt;/p&gt;
&lt;p&gt;到目前为止，东野圭吾的小说
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p>昨晚一直读到凌晨1点，酣畅淋漓。好久没有这么爽快了，这或许就是读小说的乐趣所在吧，不必绞尽脑汁去思考，只需要把身体摆成“大”字，跟随剧情，一点点被感染。读到结尾时，我甚至有种舍不得读完的感觉：“啊？就要结束了，谜团还没完全解开呐…”</p><p>到目前为止，东野圭吾的小说我一共读过两部：《解忧杂货店》、《白夜行》。怎么说呢，这是两种不同的故事风格，没什么类比性，我就不好对东野圭吾的笔法“指指点点”了。不过它们有个共同点——故事的时间跨度很大，每个章节都是碎片化的，一定要等到最后才会真相乍现。</p><p>小说最后似乎留有遗憾——雪穗的结局…但这恰恰是最值得玩味的地方，想必这恰恰会成为读者们争论的焦点。（作者的笔法真实精湛啊）</p><p>个人观点：雪穗结局已经很明显了，她不会被抓，因为<strong>她从始至终都是干净的</strong>。她也不会因为亮司的死而痛苦万分，因为<strong>他不是她爱的人</strong>。</p><p>那…</p><p><strong>雪穗和亮司到底属于什么关系？</strong></p><p>枪虾和虾虎鱼，这是小说人物给出的答案——互利共生。作为小说里的侦探和警察，他们是旁观者，能揣测出这层关系是顺利成章的。可站在上帝视角的读者（我们）直到，同样家庭关系扭曲的两个小男孩小女孩，在图书馆相遇，他们自然彼此怜惜，视对方为白夜里的光芒，照亮一片净土，慰藉怯弱的心灵。这是恋爱吗？是的！至少在桐原亮司那里是这样的。他做出了一个男孩在年少时期该有的行为，拼劲全力保护好自己的玩伴，也是初恋。</p><p>雪穗呢？不知道，那个时期的她或许真心希望有个能保护她的大哥哥吧，但也仅止于此。</p><p>“她可不是普通的狐狸精”，我比较喜欢小说里的这个评价。雪穗的美貌、气场、心机，都足以让她操纵身边的人。这些人只不过是她实现目的的一个个提线木偶，除了亮司。正如她自己所说：“我的天空里没有太阳，总是黑夜，但并不暗，因为有东西代替了太阳。”是的，亮司就是她的太阳，她从小生活在黑暗之中，早已无所畏惧，只要有一点点光，就是白天。这是她对亮司的感情，一种依靠，就像靠在大哥哥背上那样安稳。</p><p>此外，成年后的他们虽然手段卑劣，但也算挣的盆满钵满，即使不依靠对方，想必在社会上也不会混得太差。那么他们之间还需要交易吗？雪穗有，她需要很多得钱，还需要有人帮她扫清前方得障碍。亮司近乎完美地执行了。那作为报酬，亮司又从雪穗那里得到了什么？一把寒光摄人得剪刀刺穿胸膛，直达亮司得心脏，只留下那张剪纸，男孩终究是放开了女孩的手，独自背上罪孽离开了人间。</p><p>所以，互利共生的关系是说不通的。如果两人真心爱着对方，按照两人后来的智商和发展，早就可以洒脱地双宿双飞了，又何必多此一举制造一连串命案呢。答案只有一种，雪穗还有别的追求，而亮司为了让心爱的姑娘幸苦，赴汤蹈火。这注定是桐原亮司一个人的爱情。</p><p>那…</p><p><strong>雪穗到底想要什么？</strong></p><p>很难说，但我觉得不论她多么有城府，她终究是个女人！想要的依旧是鲜花和爱情。</p><p>从雪穗被领养，到两段婚姻的结果来看，显然，她越来越知书达理、光鲜亮丽、事业有成…还有多少赞美之词可以用在她身上。与她黑暗的同年想必真是天差地别。可是，为了达到这样的生活状态，真的有必要用尽各种卑劣手段残害他人吗？这么做的目的是什么？报复？证明自己？心理变态？不止于此吧，我觉得她其实就是出于一个女人的本能，在追求自己的幸福生活罢了。当然，她眼中的幸福要比一般女人“耀眼”一些，奢华一些。</p><p>说到幸福，自然少不了爱情。我想，雪穗对筱冢一成的爱是真心的。可惜这男的却轻易抵住了她的魅惑（真他妈狗血）。这或许也是她唯一没有实现的愿望吧，不然小说的篇幅就要减半了😂，</p><p>…</p><p>算了，作为一个中年油腻男，还是不要对这些情感瓜葛纠结太多。一句话：“介娘们儿可不像好银呐”。<br>碎觉去~</p>]]></content:encoded>
      
      <comments>https://ixx.life//books/%E7%99%BD%E5%A4%9C%E8%A1%8C//#disqus_thread</comments>
    </item>
    
    <item>
      <title>你的客户言非其意</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/97//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/97//</guid>
      <pubDate>Mon, 23 Mar 2020 00:09:09 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_97/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_97/" target="_blank" rel="noopener">Your Customers Do not Mean What They Say</a></p><p>我从来没有遇到过一个客户能够开心地告诉我他们想要什么——通常都是陷入细节里。问题在于客户不总是告诉你完整的真相。他们一般也不会撒谎，但他们所说的是客户术语，而非开发术语。他们使用自己术语和上下文。他们忽略了重要的细节。他们假设你已经在他们公司呆过20年，可以像他们一样。事实上很多客户根本不知道他们最想要的到底是什么，事情就会更复杂。有些人可能掌握了“全局”，但他们很难有效地传递出自己的愿景细节。其他人可能对整体愿景关注的少一些，但他们知道自己不想要的是什么。所以，你怎么可能将一个软件项目交付给一个无法告诉你自己内心想法的业主呢？非常简单。很他们更多地互动。</p><p>尽早邀请你的客户，并经常邀请他们。不要简单地用他们的词汇重复他们告诉你的想法：他们和你说的并非他们的意思。我就经常在和他们的交谈中通过交换单词并观察他们的反应来实施此建议。你会惊讶术语“顾客”和术语“客户”会有多少种全然不同的含义。和你说他在软件中想要什么的家伙会使用可交换的术语，并预计你能更上他所说的内容。但你完全迷糊了，编写的软件也会受到影响。</p><p>在你定出你所理解的对方需求之前，和你的客户进行多次主题讨论。尝试和他们复述两到三次这些问题。告诉他们事情之前或主题之后你都能获得更好的信息。尽可能，有多个人在独立的对话中和你交流相同的主题。他们几乎都会通过和你讲述不同的故事，揭露了相关事实的不同面。两个人和你交流的相同主题常常会自相矛盾。你成功的最佳机遇是在你开始那个超级复杂软件设计前，先把差异消除掉。</p><p>在你们的交谈中采用视觉辅助。可以像会议中使用白板一样简单，可以像设计初期使用可视化模型一样简单，可以像设计功能原型一样复杂。众所周知，在交谈中采用视觉辅助能够帮助我们增加注意力范围及信息留存率。为了你的项目成功，要利用好这一事实。</p><p>在以前的生涯中，我曾是个在团队里制作酷炫项目的“多媒体程序员”。我们的一位客户非常详细地描述了她对项目的看法和感受。在设计讨论会上将演示文稿的配色方案确定为黑色背景。一旦确定后，团队的图形设计师就抓紧制作了数百份图形文件。花费了大量时间来确定最终产品。次日我们向客户展示了自己的劳动成果，却得到了意想不到的答案。当她看到该产品后，她明确了对配色的用词：“当我说黑色的时候，我的意思是白色”。所以你看吧，它从来不是黑白分明的。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/97//#disqus_thread</comments>
    </item>
    
    <item>
      <title>你得关注代码</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/96//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/96//</guid>
      <pubDate>Sun, 22 Mar 2020 03:19:59 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_96/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_96/" target="_blank" rel="noopener">You Gotta Care about the Code</a></p><p>优秀的程序员不需要用夏洛克·福尔摩斯来证明其编写的代码是良好的。而坏的程序员…则不行。他们生产了垃圾却要让我们来擦屁股。你想写出优秀的作品，你想要成为一名优秀的程序员，对么？</p><p>好的代码不会凭空冒出来，这里边儿不会有运气成分。为了得到好的代码，你必须更努力的工作。如果你确实注重好的代码，你就会得到它。</p><p>好的程序并非源自技术本身。我见多那种可以生产让人敬畏的算法，以及对语言标准了然于心的高智商程序员，但写出拉锯的代码及其糟糕，难以阅读、难以应用、难以修复。我也见过很多谦逊的程序员坚持写非常简洁的代码，但他们写出来的代码非常优雅且富有表现力，用起来很开心。</p><p>基于我这些年在软件工厂的经验，我确信普通程序员和伟大程序员的真实区别在于——态度。好的编程在于采取专业的方案，并希望在软件工厂的现实约束和压力下，写出力所能及的最佳软件。</p><p>千锤百炼的代码充满了良好的意图，为了成为优秀的程序员，你必须提升自己的格局，并切实关注代码——树立正向的观念并养成健康的态度。伟大的代码都是熟练的匠人精心制作而成，而非那群草率的程序员粗糙地打造，也不会是那些自诩为编程大师的人神秘地创立的。</p><p>你想要写出优秀的代码，你想要成为优秀的程序员。那么，你就要关注代码：</p><ul><li>在任何编程情况下，你都要摒弃那种只要<code>貌似</code>能运行的事物。你要力争编写出优雅干净正确的代码（以及可以展示其正确性的良好测试）。</li><li>你编写的代码是<code>可探索的</code>（人们可以轻松地阅览和理解），是<code>可维护的</code>（你或者他人在以后能轻易进行修改），是<code>正确的</code>（你所有的步骤都是为了查明你已经解决的问题，而非只是让它看起来像是程序在跑）。</li><li>你要和其他程序员很好地协作。没有一个程序员是孤立的。少部分程序员会独自工作；但大多数工作都需要在程序员团队、公司环境、或者开源项目中完成。你要顾及其他程序员，让他人能够读懂代码架构。你想让团队尽可能写出最好的代码，超过让你自己看起来更聪明。</li><li>任何时候，只要你碰到的代码片段，都要坚持让它在你离开之后比发现它时更好（包括更好的结构、更好的测试、更具可读性…）</li><li>你关注代码及编程，所以你不断地学习新语言、风格、技术。但只有在合适的时候才会去应用它们。</li></ul><p>幸运的是，因为你想要关注代码，你读了上述这些意见。它让你感兴趣。它让你激动。享受编程快乐吧。享受削减代码来解决棘手问题的过程。生产出让你自豪的软件吧。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/96//#disqus_thread</comments>
    </item>
    
    <item>
      <title>为人们编写测试</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/95//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/95//</guid>
      <pubDate>Sat, 21 Mar 2020 00:41:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_95/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_95/" target="_blank" rel="noopener">Write Tests for People</a></p><p>你在为你的产品代码编写自动化测试。恭喜你！你还在写代码之前就写了测试？那就更棒了！！仅仅是这么做就可以让你成为一名软件工程实践的先行者。但你写的测试是优秀的吗？如果有一种提问：“我为谁而写测试？”你会怎么回答？若是回答：“为了我，在修复bug上的努力”或者“为了编译器，让它们能够跑起来”，那么你写的测试未必是最好的。所以你到底是为谁而写测试？为了那些想要了解你代码的人们。</p><p>好的测试能够充当它们正在测试的代码文档。它们描述了这些代码是如何工作的。对于每种使用场景，这些测试要：</p><ul><li>描述上下文、切入点，或者必须满足的前置条件</li><li>说明该软件是如何调用的</li><li>描述预期结果或者待验证的后置条件</li></ul><p>不同版本的使用场景都会所有不同。人们应该可以通过查看少量的测试来尝试理解你的代码，并在上述的测试三部分中进行比对，看到何种情况下会导致该软件的不同行为。每个测试都应该结合上述三条言简意赅地说明因果关系。</p><p>这意味着在测试中不可见内容与可见内容一样重要。太多的测试代码把读者的注意力转移到那些不重要的地方。只要有可能，就把这些琐碎隐藏在有意义的方法背后（“提取方法”重构会是你的朋友）。并确保你给出的每个测试都有一个能够描述场景应用的有意义的名字，好让这些测试的读者不必“逆向工程”每个测试才能理解在这种场景下的变化是什么。在此之间，测试类以及测试方法的命名至少应该包括切入点以及软件是如何调用的。可以通过扫一眼方法名就能核实测试的覆盖范围。只要测试方法名对于包含预期结果，只要它的命名不会太长以至于无法查阅，它都会很有用。</p><p>测试你的测试用例是一个不错的想法。你可以通过插入一些错误在生产环境的代码，来验证这些测试能否发现你认为应该被发现的错误（当然，你将丢掉你自己的副本）。确保它们在有帮助和有意义的方式下反馈错误。你还应该核实你的测试能够言简意赅的向那些想要理解你代码的人进行讲述。唯一的方式就是叫一个和代码无关的人来阅读你的测试，然后告诉你他从中了解到了什么。仔细听他会说些啥。如果他无法清楚地理解某件事，可能并非他不够聪明。更可能是你做的不够清楚（角色反转一下，去读读他的测试吧！）。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/95//#disqus_thread</comments>
    </item>
    
    <item>
      <title>用示例编写小函数</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/94//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/94//</guid>
      <pubDate>Wed, 18 Mar 2020 15:16:34 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_94/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_94/" target="_blank" rel="noopener">Write Small Functions Using Examples</a></p><p>我们都想编写正确的函数，并证明它是正确的。这可以让我们带着问题思考一个函数的“大小”。这不是指函数实现的代码量（尽管那也很有趣）而是指我们代码所体现的数学函数的大小。</p><p>例如，在围棋游戏中有一个称为Atari的条件，玩家的棋子可能会被对手捕获：一颗棋子周围有两个及以上的空格即自由，否则即Atari。计算一颗棋子的自由度很困难，但推断它是否为Atari就很简单。我们可以写出类似这样的函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">atari</span><span class="params">(<span class="keyword">int</span> libertyCount)</span></span></span><br><span class="line"><span class="function">  libertyCount &lt; 2</span></span><br></pre></td></tr></table></figure><p>这比看起来大。数学函数可以被理解为一个集合，即笛卡尔积的某些子集的域（这里是int）以及范围（这里是boolean）。如果这些值的集合在Java中都有相同的大小，那么集合里就会有2L<em>(Interger.MAX_VALUE+(-1L</em>Integer.MIN_VALUE)+1L)或者8,598,934,592个元素在这个int x boolean的集合内。这些子集有一半是我们的函数，因此为了完全证明该函数是正确的，我们需要4.3x109个例子来检查。</p><p>这种主张的本质是说：测试无法证明没有bug。尽管测试可以示范现有功能，但任然存在这种大小问题。</p><p>上述问题域可以帮到我们。一个棋子的自由度不会是任何int型，确切地说之会是{1,2,3,4}中的一个。因此我们可以这么写：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">LibertyCount = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;</span><br><span class="line"><span class="function"><span class="keyword">boolean</span> <span class="title">atari</span><span class="params">(LibertyCount libertyCount)</span></span></span><br><span class="line"><span class="function">  libertyCount </span>== <span class="number">1</span></span><br></pre></td></tr></table></figure><p>这就简单多了：这个函数是一个最多包涵8个成员的集合。事实上，4个检查例子就能够形成该函数正确与否的完整的证明。这就是为什么最好选用与问题域紧密相连的类型而非原始类型的原因之一。使用受域限制的类型能让我们的函数更小。找出那些类型的方法是在编写函数之前在问题域中找出用于检查的示例。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/94//#disqus_thread</comments>
    </item>
    
    <item>
      <title>编写代码，余生都要支持它</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/93//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/93//</guid>
      <pubDate>Sun, 15 Mar 2020 23:09:18 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_93/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_93/" target="_blank" rel="noopener">Write Code as If You Had to Support It for the Rest of Your Life</a></p><p>你可能会问97个人程序员应该知道什么并且如何做，可能你会得到97种不同答案。这可能会同时令人迷茫和生畏。所有的建议都是好的，所有的原则都是正确的，所有的故事都很引人注目，那么你要从哪里开始？更重要的是，一旦你开始，你又如何保持最佳的学习实践，如何确保它们能被集成进你的编程实践中呢？</p><p>我认为答案在于你的心态，确切地说，是态度。举个例子，如果你不关心你的开发伙伴、测试员、经理、销售、市场人员以及终端用户，你就不可能玩什么测试驱动开发，或在代码中写出干净的注释。我认为又一种简单的方式能够调整你的态度，并总能驱使你提交最高质量的产品：</p><p><code>编写代码，余生都要支持它</code></p><p>就它了。如果你接受这种观点，很多很棒的事情就会发生。如果你愿你让你以前或者现在的雇主深更半夜打电话给你，让你解释一下为什么当初要写<code>fooBar</code>这个方法，你就会逐渐朝专家级程序员方向发展。你会自然而然地想要更好的变量及方法的命名。你会远离那种几百行代码构成的代码块。你会寻找、学习以及应用设计模式。你会写注释、测试代码、持续重构。在余生支持你所写过的全部代码会是一次不可能的挑战。你会没得选择，但也会变得更好、更聪明、更高效。</p><p>如果你反思一下，自己写的代码在多年以后依然影响着你的职业生涯，你是否会喜欢或讨厌它。你设计并编写的每个方法、类、模块都留下了你的知识、态度、坚韧、专业、提交水准以及成就感。人们会基于他们看到的这些代码形成对你的看法。如果这些评价总是负面的，那你从你职业生涯中获得的收益会少于预期。每行代码会关系到你的职业生涯、客户、用户——编写代码，余生都要支持它。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/93//#disqus_thread</comments>
    </item>
    
    <item>
      <title>当程序员和测试员合作后</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/92//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/92//</guid>
      <pubDate>Sun, 15 Mar 2020 14:34:16 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_92/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_92/" target="_blank" rel="noopener">When Programmers and Testers Collaborate</a></p><p>当测试员和程序员开始合作后会有一些奇妙的事情发生。通过缺陷追踪系统来回发送bug所花费的时间更少。浪费在争论这是一个bug还是一个feature的时间会更少，而更多的时间则用于开发出消费者可期的良好软件。在开始写代码之前的合作将会产生很多机遇。</p><p>测试员可以通过使用他们领域的工具语言来帮助业主编写和自动验收测试，例如Fit（框架集成测试）。在开始编程之前这些测试给到程序员，团队就可以实战一把<em>验收测试驱动开发</em>（ATDD）。程序员编写用于测试的基础设施，然后编程让测试通过。这些测试就变成了回归套件的一部分。当这种合作发生后，功能测试可以尽早完成，就有时间在边缘条件或通过更大的工作流下进行探索测试。</p><p>我们可以更进一步。作为一个测试员，在程序员开始开发一个新功能前，我可以提供大量的测试想法。当我询问程序员他们是否有任何建议时，他们提供的信息也总能有助于我更好测试覆盖，或者帮助我避免花费大把时间在不必要的测试上。通常，由于测试可以让最初想法清晰化，我们就能阻止缺陷。例如，我曾经的一个项目，我给一个程序员展示Fit测试，预期的结果是一个通配符搜索的响应。而该程序员完全只打算开发关键字搜索。这样在开始编程之前我们就能和客户交流并正确地清楚。通过合作，我们阻止了缺陷，也挽回了大量被浪费掉的时间。</p><p>程序员和测试员合作也能成功创建出自动化。他们理解什么是优秀的编程实践，并帮助测试员搭建能够为整个团队工作的强大的自动化测试套件。我曾今看到过由于糟糕的测试设计而导致自动测试失败的项目。这些测试被用了太多次，要么测试员根本没有足够理解如何保持测试的独立性。测试员通常会遇到瓶颈，因此程序员在自动化任务方面与他们合作就很有意义了。和测试员工作以理解什么是清晰的测试，或许通过提供了一种简单的工具，将给予程序员另一种反馈循环，帮助他们获得长期运行的更优秀代码。</p><p>当测试员不再认为他们的工作就只是在软件中大断电然后在找出程序员代码里的bug，当程序员不再认为测试员就是“喜欢捕获他们”，合作空间就被打开了。当程序员开始意识到他们有责任构建高质量的代码，代码的可测试性自然而然就是副产品，团队就能更多地自动化回归测试。协同工作的魔法成功开启。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/92//#disqus_thread</comments>
    </item>
    
    <item>
      <title>WET稀释了性能瓶颈</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/91//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/91//</guid>
      <pubDate>Sun, 15 Mar 2020 02:29:20 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_91/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_91/" target="_blank" rel="noopener">WET Dilutes Performance Bottlenecks</a></p><p>DRY原则（Don’t Repeat Yourself）的重要性是它整理了这样一个概念：系统中的每个知识片段都应该有单一的表现形式。换而言之，每个知识点应该被包含在单独的实现中。DRY的对立面是WET（Write Every Time）。当知识点被整理在几个不同的实现中，我们的代码就是WET的。当你考虑DRY和WET的性能曲线的多种影响时，它们之间的对比就会非常明显。</p><p>让我们开始吧，假设我们系统的某个功能X是CPU的瓶颈。X功能占用30%的CPU。现在假设X功能有分散在10个不同的实现中。平均来看，每个实现都会占用3%的CPU。如果我们想快速查找问题，这种级别的CPU利用率根本不值一提。但是，假设我们以某种方式辨认出了X是性能瓶颈。现在我们剩下的问题就知识找出并修复每个单独的实现。采用WET，我们要找出并修复10处不同的实现。采用DRY，我们能清楚地看到30%的CPU利用率并在第十个代码处修复。此外，我们不必花大量时间来追踪每个实现。</p><p>有一个情况是我们经常违反DRY罪魁祸首：我们对集合的运用。实现查询功能的通用技术是通过遍历集合，然后将查询应用到每个元素：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageExample</span> </span>&#123;</span><br><span class="line">  <span class="keyword">private</span> ArrayList&lt;Customer&gt; allCustomers = <span class="keyword">new</span> ArrayList&lt;Customer&gt;();</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> ArrayList&lt;Customer&gt; <span class="title">findCustomersThatSpendAtLeast</span><span class="params">(Money amount)</span> </span>&#123; </span><br><span class="line">    ArrayList&lt;Customer&gt; customersOfInterest = <span class="keyword">new</span> ArrayList&lt;Customer&gt;();</span><br><span class="line">    <span class="keyword">for</span> (Customer customer: allCustomers) &#123; </span><br><span class="line">      <span class="keyword">if</span> (customer.spendsAtLeast(amount)) </span><br><span class="line">        customersOfInterest.add(customer);</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> customersOfInterest;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将原始集合暴露给客户端，我们就违反了封装。这不仅会限制我们的重构能力，还会强制我们的代码用户每次都用潜在的相同方式实现它们，从而违反DRY。这种状况可以通过已出原始集合暴露的API来简单避免。例如，我们可以引入一个新的领域专用集合类型<code>CustomerList</code>。这个新类更符合我们语义上的领域。所有的查询行为也更自然。</p><p>有用这个新的集合类型也可以让我们更轻松地察看是这些查询否有性能瓶颈。将查询写入类中，我们就消除了代表选择的需求，例如<code>ArrayList</code>给我们的客户端。这可以使我们更自由地改变实现，而不必担心会违反合同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">CustomerList</span> </span>&#123;</span><br><span class="line">true<span class="keyword">private</span> ArrayList&lt;Customer&gt; customers = <span class="keyword">new</span> ArrayList&lt;Customer&gt;(); </span><br><span class="line">true<span class="keyword">private</span> SortedList&lt;Customer&gt; customersSortedBySpendingLevel = <span class="keyword">new</span> SortedList&lt;Customer)(); </span><br><span class="line">true<span class="comment">// ...</span></span><br><span class="line">  <span class="function"><span class="keyword">public</span> CustomerList <span class="title">findCustomersThatSpendAtLeast</span><span class="params">(Money amount)</span> </span>&#123; </span><br><span class="line">true  <span class="keyword">return</span> <span class="keyword">new</span> CustomerList( customersSortedBySpendingLevel.elementsLargerThan(amount)); </span><br><span class="line">true&#125;</span><br><span class="line">&#125; </span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UsageExample</span> </span>&#123;</span><br><span class="line">true<span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">truetrueCustomerList customers = <span class="keyword">new</span> CustomerList();</span><br><span class="line">truetrue<span class="comment">// ...</span></span><br><span class="line">    CustomerList customersOfInterest = <span class="comment">// ...</span></span><br><span class="line">true&#125; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这上述例子中，遵循DRY，通过采用客户消费水平作为键的SortedList，允许我们来引入索引的替代方案。这个案例中更重要的细节是，遵循DRY能够帮助我们找到并修复性能瓶颈，而WET代码下是难以被发现的。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/91//#disqus_thread</comments>
    </item>
    
    <item>
      <title>繁琐的日志会打扰你睡觉</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/90//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/90//</guid>
      <pubDate>Sun, 15 Mar 2020 00:49:53 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_90/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_90/" target="_blank" rel="noopener">Verbose Logging Will Disturb Your Sleep</a></p><p>当我遇到一个已经开发并在生产环境跑了一段时间的系统时，我最怕的就是那个脏日志。你知道我在说什么：当点击web页面上那个单连接，系统就会反馈犹如潮水般的日志消息出来。可过多的日志根本没什么用。</p><p>如果你的系统想我一样，你完成工作后，其他人则刚刚开始。系统开发完成后，希望它能活得久一点、富有生命力一点去服务客户（如果你足够幸运）。你怎么知道当系统在生产环境中是否会挂掉呢，你又该如何处理呢？</p><p>可能有人会为你监视系统，或者可能是你自己监视它。不管是哪种方式，日志都可能是监视的一部分。如果出现突发状况，你不得不起床应对，你当然希望确保对此有个良好的缘由。如果我的系统挂了，我也希望如此。但如果它只是出了点小问题，我更喜欢回到美梦里。</p><p>对于很多系统，第一个标志是将错误消息写入某些日志。通常，这些就是错误日志。所以请帮自己一个忙：在白天的时候就要确保哪些内容如果记录在错误日志中，你就会在半夜被其他人的电话叫醒。如果你可以在你的测试系统上模拟负载，并看到一个无噪音的错误日志也能很好地表明你的系统相当健壮——如果看不到，那就早点发出警告。</p><p>分布式系统的复杂度还要再增加一级。你必须决定如何处理外部依赖的失败。如果你的系统非常分散，这种状况就会经常发生。要确保你的日志策略要将其考虑在内。</p><p>一般来说，最好的迹象就是所有事情都正确，消息也在低优先级快乐地滴答。对于每个应用程序的事件，我都能掌握对应级别的日志消息。</p><p>日志混乱表明系统一旦投入生产环境将很难控制。如果你不希望任何事情都展现在错误日志中。那当出现某些状况后，知道下一步做什么就会变得更容易。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/90//#disqus_thread</comments>
    </item>
    
    <item>
      <title>采用正确的算法和数据结构</title>
      <link>https://ixx.life//97ThingsEveryProgrammerShouldKnow/89//</link>
      <guid>https://ixx.life//97ThingsEveryProgrammerShouldKnow/89//</guid>
      <pubDate>Sat, 14 Mar 2020 15:47:41 GMT</pubDate>
      <description>
      
        
        
          &lt;p&gt;&lt;a href=&quot;https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_89/&quot; target=&quot;_blank&quot; r
        
      
      </description>
      
      
      <content:encoded><![CDATA[<p><a href="https://97-things-every-x-should-know.gitbooks.io/97-things-every-programmer-should-know/content/en/thing_89/" target="_blank" rel="noopener">Use the Right Algorithm and Data Structure</a></p><p><em>一家用于众多分行的大型银行他们给出纳新采购的电脑实在太慢了。那个时候还没有电子银行，也不想现在到处都是ATM机。人们会经常去银行办理业务，由于电脑慢导致人们排起长队。因此，这家银行向供应商威胁要终止合同。</em></p><p><em>供应商急忙发送一份性能分析，为了查明延迟原因还派遣了一名专家过去。他立刻就发现跑在终端的一段特殊代码几乎耗尽了CPU资源。通过图表分析工具，他放大了这段程序，并看到了这个罪魁祸首的函数。源码大致为：</em></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;<span class="built_in">strlen</span>(s); ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (... s[i] ...) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><em>而且字符串s平均都有上千个字符。这段代码（银行写的）很快变更正了。从此以后银行的出纳员过上了幸福快乐的生活。</em></p><p>相对于使用不必要的嵌套扩展代码，程序员不应该做得更好吗？</p><p>每次调用strlen传递的每个字符上千遍，知道字符串发现null结束符。然后这期间该字符串就从未变化过。为了进一步使用它的长度，程序员可以先吊用strlen并将其保存（并把它执行个几百万次）：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">n=<span class="built_in">strlen</span>(s);</span><br><span class="line"><span class="keyword">for</span> (i=<span class="number">0</span>; i&lt;n; ++i) &#123;</span><br><span class="line">    <span class="keyword">if</span> (... s[i] ...) ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>每个人都知道这个格言：“先让它跑起来，再让他快起来”，才能避免微优化陷阱。但上边的例子似乎让你相信，程序员遵循的是Machiavellian格言：“先让它慢慢跑吧”。</p><p>你可能遇到过不止一次这种欠考虑的事情。这不仅仅是“不要重新发明轮子”的事情。有时候初级程序员只是再打字而非思考，当他们突然间“发明”了冒泡排序时。他们甚至会开始吹嘘它。</p><p>选择正确算法的另一面就是数据结构的选择。这会有很大的不同：采用链表来遍历一个用于百万个项的集合（相比较哈希数据结构或二叉树），用户对你程序的评价都会产生很大的影响。</p><p>程序员不应该重新发明轮子，应该尽可能使用现有库。但为避免像上面那家银行的问题，他们也该学习有关算法以及它们如果扩展。现代令人眼花缭乱的文本编辑器会让它们变得像1980年代的WordStar一样慢么？很多人说程序中的复用很重要。然而综上考虑，程序员应该要知道何时、何处、如何服用。为了完成这个，他们应该具备这些问题域喝算法及数据结构的相关知识。</p><p>一个好的程序员也应该知道什么时候该用一种平庸的算法。例如，如果问题域是永远不会有超过5个项的算法（例如快艇骰子游戏），你就知道你必须进行5个元素的排序。对于这种案例，冒泡排序实际上会比绝大多数其它排序方法都更高效。每条狗都会有自己的一天。</p><p>所以，阅读一些好书吧——要确保你理解它们。如果你真的看过Donald Knuth<br>的《计算机程序设计技术》，很好，祝你好运：发现作者的一个错误，你就能得到十六进制美元（$2.56）支票。</p>]]></content:encoded>
      
      <comments>https://ixx.life//97ThingsEveryProgrammerShouldKnow/89//#disqus_thread</comments>
    </item>
    
  </channel>
</rss>
